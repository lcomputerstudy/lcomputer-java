package com.lcomputerstudy.book.java.ch1;

public class Variable2 {

	public static void main(String[] args) {
		byte b = 1;			// 정수형 (메모리 크기: 1Byte, 표현 범위: -128 ~ 127)
		short s = 2;		// 정수형 (메모리 크기: 2Byte, 표현 범위: -32,768 ~ 32,767)
		int i = 3;			// 정수형 (메모리 크기: 4Byte, 표현 범위: -2,147,483,648 ~ 2,147,483,647)
		long l = 4L;		// 정수형 (메모리 크기: 8Byte, 표현 범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)
		
		System.out.println(s);
		s = 32767;
		System.out.println(s);
		// s = 32768;		// 표현 범위를 벗어났기 때문에 컴파일 에러가 발생한다.
		s = -32768;
		System.out.println(s);
		// s = -32769;		// 표현 범위를 벗어났기 때문에 컴파일 에러가 발생한다.
		
		float f = 5.333333f;			// 실수형 (메모리 크기: 4Byte, 7자리까지 표현 가능)
		double d = 7.777777777777777;	// 실수형 (메모리 크기: 8Byte, 16자리까지 표현 가능)
		System.out.println(f);			// 7자리 모두 정확하게 표현된다.
		System.out.println(d);			// 16자리 모두 정확하게 표현된다.
		
		f = 5.3333333f;
		d = 7.7777777777777777;
		System.out.println(f);			// 7자리 넘을 경우 반올림 되어 정확하게 표현되지 않는다.
		System.out.println(d);			// 16자리 넘을 경우 반올림 되어 정확하게 표현되지 않는다.
		
		f = 55.333333f;
		d = 77.7777777777778685;
		System.out.println(f);			// 정수부와 소수부를 모두 포함하여 7자리까지만 제대로 표현되는 것을 볼 수 있다.
		System.out.println(d);			// 정수부와 소수부를 모두 포함하여 16자리까지만 제대로 표현되는 것을 볼 수 있다.
		
		int i2 = 30;					// i2는 변수고 변수에 대입하기 전의 30은 리터럴이라고 한다.
										// 30 이라는 리터럴을 변수 i2에 저장하는 것이다.
		long l2 = 55L;					// 55L 이라는 long 타입 리터럴 55 를 long 타입 변수 l2 에 대입한다.  
		
		int i3 = 789_235_678;			// 숫자가 너무 길어 헷갈릴 때 _를 이용해 보기 쉽게 표현할 수 있다.
		System.out.println(i3);
		
		boolean isChecked;				// true, false 두 가지 값만 가질 수 있는 데이터 타입이다.
		isChecked = true;				// 참
		System.out.println(isChecked);
		isChecked = false;				// 거짓
		System.out.println(isChecked);
		
		char ch = 97;					// 정수형 (메모리 크기: 2Byte, 0 ~ 65535 사이의 숫자를 가질 수 있다.)
		System.out.println(ch);			// 유니코드의 97번에 해당하는 문자를 출력
		ch = 70;
		System.out.println(ch);			// 유니코드의 70번은 대문자 F인 것을 알 수 있다.
		ch = 'L';						// 유니코드에서 L 에 해당하는 숫자로 변환되어 저장된다.
		System.out.println(ch);			// char 변수에 저장된 숫자를 유니코드에서 찾아 해당 문자를 출력한다.
	}

}

/*
 * 변수에 저장되기 전의 숫자나 문자를 리터럴이라고 한다.
 *		3 은 정수 리터럴이다.
 *		75 는 정수 리터럴이다.
 *		85L 은 long 타입 정수 리터럴이다.
 *		85 는 int 타입 정수 리터럴이다.
 *			리터럴도 타입에 따라 표현 범위가 달라지게 된다.
 *
 *		'a' 는 문자 리터럴이다.
 *
 *		"abc" 는 문자열 리터럴이다.
 *
 *		27.5 는 double 타입의 실수 리터럴이다.
 *		27.5f 는 float 타입의 실수 리터럴이다.
 *			f를 붙이면 float 타입의 리터럴이 되고 붙이지 않으면 double 타입의 리터럴이 된다.
 *				리터럴도 float 과 double 타입에 따라 자릿수 표현 정확도가 달라지게 된다. 
 *
 * 		정수에 l 을 붙여주면 long 타입 리터럴이 되고 붙이지 않으면 int 타입 리터럴이 된다.
 * 		실수에 f 를 붙여주면 float 타입 리터럴이 되고 붙이지 않으면 double 타입 리터럴이 된다.
 * 
 * 		- 몰라도 되는 부분 -  실수는 부호, 가수, 지수를 이용해 표현하게 되는데 지수를 이용해 소수점을 이동시켜 표현하기 때문에 부동소수점 수라고 부른다. 
 * 
 * 유니코드란 문자표이 *** 작업중 
 * 		
 * bit는 컴퓨터에서 데이터를 표현할 때 사용되는 최소 단위이다.
 * 		1 bit 는 0 또는 1을 표현할 수 있다.
 * 			이를 이용해 2진수를 표현할 수 있다.
 * 			1 bit 가 8개 모이면 8 bit 가 되고 11111111 과 같이 2진수를 표현할 수 있다. 
 * 				10진수로 변환하면 256 이 된다.
 * 			맨 왼쪽의 비트를 최상위 비트라 부른다. 
 * 				최상위 비트는 부호 비트로 사용되며 0은 양수 1은 음수가 된다.
 * 			8비트가 가질 수 있는 표현 범위는 -128 ~ +127 이 된다.
 * 				-127이 아닌 -128이 되는 이유는 2의 보수로 음수를 표현하기 때문이다.
 * 					최상위 비트를 1로만 바꿔서는 2진수의 계산이 어렵다.
 * 						때문에 1의 보수를 사용하여 위 문제를 해결한다.
 * 							하지만 1의 보수는 -0, +0 처럼 0이 두개가 생기는 문제가 있다.
 * 								1의 보수에서 1을 더하는 2의 보수로 위 문제를 해결한다.
 * 									2의 보수를 적용하면 -127이 아닌 -128까지 표현할 수 있게 되며 0은 하나만 있게 된다.
 * 				아래는 2의 보수 표현 방법에 대한 설명이다.
 * 					양수 2를 비트로 표현하면 아래와 같다.
 * 						00000010 = +2
 * 					음수 2를 표현하기 위해 우선 1의 보수로 변환한다.
 * 						1의 보수로 만들기 위해 0은 1로 1은 0으로 바꿔 준다.
 * 							11111101 은 -2를 1의 보수로 표현한 것이다.
 * 								1의 보수인 11111101 에 1 을 더하면 2의 보수가 된다.
 * 									2의 보수인 11111110 의 값을 확인하기 위해서는
 * 										11111110 에서 1을 뺀다.
 * 											11111101 최상위 비트 1은 음수 부호로 쓰고 나머지 비트들은 0은 1로 1은 0으로 바꾼다.
 * 												10000010 은 -2 인 것을 알 수 있다.
 * 		1 bit = 0 or 1
 * 		8 bit = 1 Byte
 * 		1024 Byte = 1 KB (킬로바이트)
 * 		1024 KB = 1 MB (메가바이트)
 * 		1024 MB = 1 GB (기가바이트)
 * 
 * */
